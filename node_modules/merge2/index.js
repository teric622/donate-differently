'use strict'
/*
 * merge2
 * https://github.com/teambition/merge2
 *
<<<<<<< HEAD
 * Copyright (c) 2014-2020 Teambition
=======
<<<<<<< HEAD
<<<<<<< HEAD
 * Copyright (c) 2014-2020 Teambition
=======
 * Copyright (c) 2014-2016 Teambition
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
 * Copyright (c) 2014-2020 Teambition
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
>>>>>>> 71cc80d5c04c1d732a53d72b3d4830571f913b17
 * Licensed under the MIT license.
 */
const Stream = require('stream')
const PassThrough = Stream.PassThrough
const slice = Array.prototype.slice

module.exports = merge2

function merge2 () {
  const streamsQueue = []
<<<<<<< HEAD
=======
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
>>>>>>> 71cc80d5c04c1d732a53d72b3d4830571f913b17
  const args = slice.call(arguments)
  let merging = false
  let options = args[args.length - 1]

  if (options && !Array.isArray(options) && options.pipe == null) {
    args.pop()
  } else {
    options = {}
  }

  const doEnd = options.end !== false
  const doPipeError = options.pipeError === true
  if (options.objectMode == null) {
    options.objectMode = true
  }
  if (options.highWaterMark == null) {
    options.highWaterMark = 64 * 1024
  }
<<<<<<< HEAD
=======
<<<<<<< HEAD
=======
  let merging = false
  const args = slice.call(arguments)
  let options = args[args.length - 1]

  if (options && !Array.isArray(options) && options.pipe == null) args.pop()
  else options = {}

  const doEnd = options.end !== false
  if (options.objectMode == null) options.objectMode = true
  if (options.highWaterMark == null) options.highWaterMark = 64 * 1024
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
>>>>>>> 71cc80d5c04c1d732a53d72b3d4830571f913b17
  const mergedStream = PassThrough(options)

  function addStream () {
    for (let i = 0, len = arguments.length; i < len; i++) {
      streamsQueue.push(pauseStreams(arguments[i], options))
    }
    mergeStream()
    return this
  }

  function mergeStream () {
<<<<<<< HEAD
    if (merging) {
      return
    }
=======
<<<<<<< HEAD
<<<<<<< HEAD
    if (merging) {
      return
    }
=======
    if (merging) return
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
    if (merging) {
      return
    }
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
>>>>>>> 71cc80d5c04c1d732a53d72b3d4830571f913b17
    merging = true

    let streams = streamsQueue.shift()
    if (!streams) {
      process.nextTick(endStream)
      return
    }
<<<<<<< HEAD
    if (!Array.isArray(streams)) {
      streams = [streams]
    }
=======
<<<<<<< HEAD
<<<<<<< HEAD
    if (!Array.isArray(streams)) {
      streams = [streams]
    }
=======
    if (!Array.isArray(streams)) streams = [streams]
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
    if (!Array.isArray(streams)) {
      streams = [streams]
    }
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
>>>>>>> 71cc80d5c04c1d732a53d72b3d4830571f913b17

    let pipesCount = streams.length + 1

    function next () {
<<<<<<< HEAD
      if (--pipesCount > 0) {
        return
      }
=======
<<<<<<< HEAD
<<<<<<< HEAD
      if (--pipesCount > 0) {
        return
      }
=======
      if (--pipesCount > 0) return
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
      if (--pipesCount > 0) {
        return
      }
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
>>>>>>> 71cc80d5c04c1d732a53d72b3d4830571f913b17
      merging = false
      mergeStream()
    }

    function pipe (stream) {
      function onend () {
        stream.removeListener('merge2UnpipeEnd', onend)
        stream.removeListener('end', onend)
<<<<<<< HEAD
=======
<<<<<<< HEAD
<<<<<<< HEAD
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
>>>>>>> 71cc80d5c04c1d732a53d72b3d4830571f913b17
        if (doPipeError) {
          stream.removeListener('error', onerror)
        }
        next()
      }
      function onerror (err) {
        mergedStream.emit('error', err)
      }
      // skip ended stream
      if (stream._readableState.endEmitted) {
        return next()
      }

      stream.on('merge2UnpipeEnd', onend)
      stream.on('end', onend)

      if (doPipeError) {
        stream.on('error', onerror)
      }

<<<<<<< HEAD
=======
<<<<<<< HEAD
=======
        next()
      }
      // skip ended stream
      if (stream._readableState.endEmitted) return next()

      stream.on('merge2UnpipeEnd', onend)
      stream.on('end', onend)
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
>>>>>>> 71cc80d5c04c1d732a53d72b3d4830571f913b17
      stream.pipe(mergedStream, { end: false })
      // compatible for old stream
      stream.resume()
    }

<<<<<<< HEAD
    for (let i = 0; i < streams.length; i++) {
      pipe(streams[i])
    }
=======
<<<<<<< HEAD
<<<<<<< HEAD
    for (let i = 0; i < streams.length; i++) {
      pipe(streams[i])
    }
=======
    for (let i = 0; i < streams.length; i++) pipe(streams[i])
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
    for (let i = 0; i < streams.length; i++) {
      pipe(streams[i])
    }
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
>>>>>>> 71cc80d5c04c1d732a53d72b3d4830571f913b17

    next()
  }

  function endStream () {
    merging = false
    // emit 'queueDrain' when all streams merged.
    mergedStream.emit('queueDrain')
<<<<<<< HEAD
    if (doEnd) {
      mergedStream.end()
    }
=======
<<<<<<< HEAD
<<<<<<< HEAD
    if (doEnd) {
      mergedStream.end()
    }
=======
    return doEnd && mergedStream.end()
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
    if (doEnd) {
      mergedStream.end()
    }
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
>>>>>>> 71cc80d5c04c1d732a53d72b3d4830571f913b17
  }

  mergedStream.setMaxListeners(0)
  mergedStream.add = addStream
  mergedStream.on('unpipe', function (stream) {
    stream.emit('merge2UnpipeEnd')
  })

<<<<<<< HEAD
  if (args.length) {
    addStream.apply(null, args)
  }
=======
<<<<<<< HEAD
<<<<<<< HEAD
  if (args.length) {
    addStream.apply(null, args)
  }
=======
  if (args.length) addStream.apply(null, args)
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
  if (args.length) {
    addStream.apply(null, args)
  }
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
>>>>>>> 71cc80d5c04c1d732a53d72b3d4830571f913b17
  return mergedStream
}

// check and pause streams for pipe.
function pauseStreams (streams, options) {
  if (!Array.isArray(streams)) {
    // Backwards-compat with old-style streams
<<<<<<< HEAD
    if (!streams._readableState && streams.pipe) {
      streams = streams.pipe(PassThrough(options))
    }
=======
<<<<<<< HEAD
<<<<<<< HEAD
    if (!streams._readableState && streams.pipe) {
      streams = streams.pipe(PassThrough(options))
    }
=======
    if (!streams._readableState && streams.pipe) streams = streams.pipe(PassThrough(options))
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
    if (!streams._readableState && streams.pipe) {
      streams = streams.pipe(PassThrough(options))
    }
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
>>>>>>> 71cc80d5c04c1d732a53d72b3d4830571f913b17
    if (!streams._readableState || !streams.pause || !streams.pipe) {
      throw new Error('Only readable stream can be merged.')
    }
    streams.pause()
  } else {
<<<<<<< HEAD
    for (let i = 0, len = streams.length; i < len; i++) {
      streams[i] = pauseStreams(streams[i], options)
    }
=======
<<<<<<< HEAD
<<<<<<< HEAD
    for (let i = 0, len = streams.length; i < len; i++) {
      streams[i] = pauseStreams(streams[i], options)
    }
=======
    for (let i = 0, len = streams.length; i < len; i++) streams[i] = pauseStreams(streams[i], options)
>>>>>>> 782567c486993431d88a7d42ed2c18702ecdfd4f
=======
    for (let i = 0, len = streams.length; i < len; i++) {
      streams[i] = pauseStreams(streams[i], options)
    }
>>>>>>> b9690f13ae0b02552662ffbd680e2069f9283c9e
>>>>>>> 71cc80d5c04c1d732a53d72b3d4830571f913b17
  }
  return streams
}
